// src/stores/dependency-store.extensions.ts
// Extensions & advanced patterns for the dependency store

import { useDependencyStore } from './dependency-store';
import { FileUsage } from './dependency-store';

/**
 * EXTENSION 1: Auto-Scan on Interval
 * Automatically re-scan every 30 seconds
 */
export const enableAutoScan = (intervalMs: number = 30000) => {
  const { startScan } = useDependencyStore.getState();
  
  const interval = setInterval(() => {
    startScan();
  }, intervalMs);
  
  // Return cleanup function
  return () => clearInterval(interval);
};

/**
 * EXTENSION 2: File Watcher Integration
 * Re-scan when files change (requires chokidar)
 * Installation: npm install chokidar
 */
export const enableFileWatcher = async () => {
  try {
    const chokidar = await import('chokidar');
    const { startScan } = useDependencyStore.getState();
    
    const watcher = chokidar.watch('./src', {
      persistent: true,
      awaitWriteFinish: {
        stabilityThreshold: 2000,
        pollInterval: 100,
      }
    });
    
    watcher.on('change', () => {
      console.log('File changed, rescanning...');
      startScan();
    });
    
    return () => watcher.close();
  } catch (error) {
    console.error('File watcher not available:', error);
    return () => {};
  }
};

/**
 * EXTENSION 3: Export Results
 * Export scan results as CSV
 */
export const exportResultsAsCSV = () => {
  const { files, health } = useDependencyStore.getState();
  
  const headers = ['File', 'Status', 'Imports Count', 'Lines', 'Path'];
  const rows = files.map(f => [
    f.name,
    f.isUsed ? 'Used' : 'UNUSED',
    f.importedBy.length,
    f.lineCount || 0,
    f.path
  ]);
  
  const csv = [
    `Health Score,${health.healthScore}%`,
    `Last Scan,${health.lastScan ? new Date(health.lastScan).toISOString() : 'Never'}`,
    `Total Files,${health.totalFiles}`,
    `Used Files,${health.usedFiles}`,
    `Unused Files,${health.unusedFiles}`,
    '',
    headers.join(','),
    ...rows.map(r => r.map(cell => `"${cell}"`).join(','))
  ].join('\n');
  
  // Download file
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `dependency-health-${Date.now()}.csv`;
  a.click();
  window.URL.revokeObjectURL(url);
};

/**
 * EXTENSION 4: GitHub Integration
 * Auto-create issue for unused files
 */
export const createGitHubIssueForUnused = async (token: string, owner: string, repo: string) => {
  const { files, health } = useDependencyStore.getState();
  const unusedFiles = files.filter(f => !f.isUsed);
  
  if (unusedFiles.length === 0) {
    console.log('No unused files to report');
    return;
  }
  
  const body = `## Dependency Health Report
  
**Health Score:** ${health.healthScore}%
**Total Files:** ${health.totalFiles}
**Unused Files:** ${unusedFiles.length}

### Unused Files to Clean Up:
${unusedFiles.map(f => `- \`${f.name}\` (${f.lineCount} lines, path: \`${f.path}\`)`).join('\n')}

*Generated by WWCD Dependency Health Dashboard*
`;
  
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues`, {
      method: 'POST',
      headers: {
        'Authorization': `token ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        title: `üßπ Dependency Cleanup: ${unusedFiles.length} unused files found`,
        body,
        labels: ['enhancement', 'maintenance']
      })
    });
    
    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
    const issue = await response.json();
    console.log('Created GitHub issue:', issue.html_url);
    return issue;
  } catch (error) {
    console.error('Failed to create GitHub issue:', error);
    throw error;
  }
};

/**
 * EXTENSION 5: CI/CD Integration
 * Check health score and fail if below threshold
 */
export const checkHealthThreshold = (threshold: number = 70): boolean => {
  const { health } = useDependencyStore.getState();
  
  if (health.healthScore < threshold) {
    const message = `‚ùå Project health (${health.healthScore}%) is below threshold (${threshold}%). Found ${health.unusedFiles} unused files.`;
    console.error(message);
    return false;
  }
  
  console.log(`‚úÖ Project health (${health.healthScore}%) meets threshold`);
  return true;
};

/**
 * EXTENSION 6: Pattern Analysis
 * Identify patterns in unused files
 */
export const analyzeUnusedPatterns = () => {
  const { files } = useDependencyStore.getState();
  const unusedFiles = files.filter(f => !f.isUsed);
  
  const patterns = {
    endsWith: {} as Record<string, number>,
    folder: {} as Record<string, number>,
    sizeRange: {
      small: 0,    // < 50 lines
      medium: 0,   // 50-200 lines
      large: 0     // > 200 lines
    }
  };
  
  for (const file of unusedFiles) {
    // Pattern by suffix
    const suffix = file.name.match(/[a-z]+$/)?.[0] || 'unknown';
    patterns.endsWith[suffix] = (patterns.endsWith[suffix] || 0) + 1;
    
    // Pattern by folder
    patterns.folder[file.folder] = (patterns.folder[file.folder] || 0) + 1;
    
    // Pattern by size
    if ((file.lineCount || 0) < 50) patterns.sizeRange.small++;
    else if ((file.lineCount || 0) < 200) patterns.sizeRange.medium++;
    else patterns.sizeRange.large++;
  }
  
  return patterns;
};

/**
 * EXTENSION 7: Smart Recommendations
 * Generate AI-powered cleanup recommendations
 */
export const generateRecommendations = async () => {
  const { files, health } = useDependencyStore.getState();
  const patterns = analyzeUnusedPatterns();
  const unusedFiles = files.filter(f => !f.isUsed);
  
  const recommendations = [
    health.healthScore < 60 && {
      priority: 'HIGH',
      action: 'Delete all unused files',
      reason: 'Health score critically low',
      impact: `Would improve health by ${Math.round((unusedFiles.length / files.length) * 100)}%`
    },
    
    (patterns.endsWith['service'] || 0) > 2 && {
      priority: 'MEDIUM',
      action: 'Review old service files',
      reason: 'Multiple unused service files detected',
      files: unusedFiles.filter(f => f.name.includes('service')).map(f => f.name)
    },
    
    unusedFiles.some(f => (f.lineCount || 0) > 200) && {
      priority: 'HIGH',
      action: 'Remove large unused files first',
      reason: 'Large unused files consume significant space',
      impact: `Could save ${unusedFiles.filter(f => (f.lineCount || 0) > 200).length} files worth of code`
    },
    
    health.healthScore >= 80 && {
      priority: 'LOW',
      action: 'Maintain current practices',
      reason: 'Codebase is well-maintained',
      suggestion: 'Keep regular scans to prevent unused code accumulation'
    }
  ].filter(Boolean);
  
  return recommendations;
};

/**
 * EXTENSION 8: Batch Operations
 * Safely delete multiple unused files at once
 */
export const batchDeleteUnused = async (maxFilesToDelete: number = 5) => {
  const { files, deleteUnusedFile } = useDependencyStore.getState();
  const unusedFiles = files.filter(f => !f.isUsed).slice(0, maxFilesToDelete);
  
  console.log(`Deleting ${unusedFiles.length} unused files...`);
  
  for (const file of unusedFiles) {
    try {
      await deleteUnusedFile(file.id);
      console.log(`‚úÖ Deleted: ${file.name}`);
    } catch (error) {
      console.error(`‚ùå Failed to delete ${file.name}:`, error);
    }
  }
  
  console.log(`Batch delete complete. Deleted ${unusedFiles.length} files.`);
};

/**
 * EXTENSION 9: Timeline Tracking
 * Track health over time
 */
interface HealthSnapshot {
  timestamp: number;
  healthScore: number;
  totalFiles: number;
  unusedFiles: number;
}

let healthTimeline: HealthSnapshot[] = [];

export const captureHealthSnapshot = () => {
  const { health } = useDependencyStore.getState();
  healthTimeline.push({
    timestamp: Date.now(),
    healthScore: health.healthScore,
    totalFiles: health.totalFiles,
    unusedFiles: health.unusedFiles
  });
};

export const getHealthTrend = () => {
  if (healthTimeline.length < 2) return null;
  
  const latest = healthTimeline[healthTimeline.length - 1];
  const previous = healthTimeline[healthTimeline.length - 2];
  
  return {
    scoreDelta: latest.healthScore - previous.healthScore,
    filesDelta: latest.unusedFiles - previous.unusedFiles,
    trend: latest.healthScore > previous.healthScore ? 'improving' : 'declining'
  };
};

/**
 * EXTENSION 10: Slack Notifications
 * Send health report to Slack
 */
export const sendSlackNotification = async (webhookUrl: string) => {
  const { health } = useDependencyStore.getState();
  const recommendations = await generateRecommendations();
  
  const color = health.healthScore >= 80 ? '#10b981' : health.healthScore >= 60 ? '#f59e0b' : '#ef4444';
  
  try {
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        attachments: [{
          color,
          title: 'üß† WWCD Dependency Health Report',
          fields: [
            {
              title: 'Health Score',
              value: `${health.healthScore}%`,
              short: true
            },
            {
              title: 'Files',
              value: `${health.totalFiles} total | ${health.usedFiles} used | ${health.unusedFiles} unused`,
              short: false
            },
            {
              title: 'Top Recommendation',
              value: recommendations[0]?.action || 'No action needed',
              short: false
            }
          ],
          footer: 'Dependency Health Dashboard'
        }]
      })
    });
    
    if (!response.ok) throw new Error('Slack API error');
    console.log('‚úÖ Slack notification sent');
  } catch (error) {
    console.error('‚ùå Failed to send Slack notification:', error);
  }
};

export default {
  enableAutoScan,
  enableFileWatcher,
  exportResultsAsCSV,
  createGitHubIssueForUnused,
  checkHealthThreshold,
  analyzeUnusedPatterns,
  generateRecommendations,
  batchDeleteUnused,
  captureHealthSnapshot,
  getHealthTrend,
  sendSlackNotification
};
